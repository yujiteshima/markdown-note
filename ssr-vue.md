# Vue SSR

## サーバーサイドレンダリング（SSR）とは何か？
---
>Vue.js はクライアントサイドアプリケーションを構築するためのフレームワークである。
通常では（SSRではないSPAの場合）、Vue コンポーネントはブラウザで DOM をレンダリングする。
しかし、同じ Vue コンポーネントをサーバ上の HTML 文字列に描画し、ブラウザに直接送信し、最終的に静的なマークアップとしてクライアント上の完全なインタラクティブアプリケーションに "ハイドレート (hydrate)" することが出来る。
サーバで描画された Vue.js のアプリケーションは、アプリケーションのコードの大部分が、サーバとクライアントの両方で実行されるという意味で、"アイソモルフィック (isomorphic)" や "ユニバーサル (universal)" と見なすことができます。

こういう事？

SSRでない場合は、バンドルされたJSがブラウザに渡り、ブラウザからAPIを叩いてデータを取得したり、ブラウザでHTMLをレンダリングしたりする。
SSRではサーバーサイドでも同じようにJSを動作させて、APIを叩いてデータを取得したり、HTMLをレンダリングして、それをブラウザに送信する。
サーバーサイドのHTMLを送信するタイミングで、バンドルしたJSをブラウザに送信するのか、リクエストがあったタイミングでJSを送信するのかはこれからの勉強であるが、ブラウザ側では、公式にあるハイドレート (hydrate)という処理を行なって行くということか？


```
src
├── components
│   ├── Foo.vue
│   ├── Bar.vue
│   └── Baz.vue
├── App.vue
├── app.js # 共通のエントリ
├── entry-client.js # ブラウザでのみ実行される
└── entry-server.js # サーバでのみ実行される
```

![SSRの流れ、公式より転載](./images/vue-ssr-public.png "ssr")

### app.js

app.js はアプリケーションのユニバーサルエントリーである。クライアントアプリケーションでは、このファイルにルート Vue インスタンスを作成し、DOM に直接マウントする。しかし、SSRの場合は責務はクライアント専用のエントリファイルに映されます。app.js はシンプルに createApp 関数をエクスポートする:
```js
// app.js
import Vue from 'vue'
import App from './App.vue'

// 新しいアプリケーション、ルータ、ストアを作成するためのファクトリ関数をエクスポートする
// インスタンス
export function createApp() {
  const app = new Vue({
    // ルートインスタンスは単にAppコンポーネントを描画する
    render: h => h(App)
  })
  return { app }
}
```

### entry-client.js:

クライアントエントリは単にアプリケーションを作成しそれをDOMにマウントする：
```js
// entry-client.js
import { createApp } from './app'

// クライアント固有の初期化ロジック
const { app } = createApp()
// これは App.vue テンプレートのルート要素が id="app" だから
app.$mount('#app')
```

### entry-server.js:

サーバーエントリは描画ごとに繰り返し呼び出すことができる関数を```default export```する。現時点では、アプリケーションインスタンスを作成して返す以外のことはほとんど行わないが、後でサーバーサイドのルートマッチングとデータプリフェッチロジックを実行する
。
```js
// entry-server.js
import { createApp } from './app'

export default context => {
  const { app } = createApp()
  return app
}
```

## クライアントサイドでのハイドレーション
entry-client.js において、以下の記述で私たちは簡単にアプリケーションをマウントします:
```js
// これは、ルート要素に id="app" をもつ App.vue テンプレートを想定します
app.$mount('#app')
```
サーバがマークアップを描画後に、この処理を実行し、すべての DOM を再生成することを私たちは当然したくありません。代わりに、静的なマークアップの"ハイドレート (hydrate)"とそれをインタラクティブに生成したいです。

サーバの描画出力を調べたら、アプリケーションのルート要素が以下のような特別な属性を持っていることに気づくでしょう:

```html
<div id="app" data-server-rendered="true">
```
この data-server-rendered という特別な属性は、クライアントサイドの Vue に、これがサーバ上で描画されたことを知らせ、この要素はハイドレーションモードでマウントされるはずです。id="app" に、単に data-server-rendered が追加されていないことに注意してください。ID または 他のセレクタを自分自身のルート要素に追加する必要があります。そうしないと、アプリケーションが適切にハイドレーションできなくなります。

開発モードでは、Vue はクラインアントサイドで生成された仮想 DOM が、サーバで描画された DOM の構成と一致しているか検証を行います。もしこれが一致していない場合、ハイドレーションを取りやめ、元の DOM を無視しスクラッチから描画を行います。プロダクションモードでは、パフォーマンスの最大化のため、このアサーションは無効になります。

### ハイドレーション時の注意
サーバサイドの描画とクライアントサイドでのハイドレーションを行なった場合、ある特定の HTML の構造はブラウザによって変換されるかもしれないことがわかっています。例えば、あなたが Vue のテンプレート内に、以下のような記述をした場合です:

```html
<table>
  <tr><td>hi</td></tr>
</table>
```

ブラウザは、自動で \<tbody> を \<table> に挿入します。しかし、Vue によって生成された仮想 DOM は、\<tbody> を含みません。そのため、不一致が起こります。正しいマッチングを保証するために、あなたのテンプレート内では、必ず有効な HTML を記述してください。